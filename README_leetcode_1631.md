# LeetCode 1631: 最小体力消耗路径

## 题目描述

你准备参加一场远足活动。给你一个二维 `rows x columns` 的地图 `heights`，其中 `heights[row][col]` 表示格子 `(row, col)` 的高度。一开始你在最左上角的格子 `(0, 0)`，且你希望去最右下角的格子 `(rows-1, columns-1)`（注意下标从 0 开始编号）。你每次可以往**上，下，左，右**四个方向之一移动，你想要找到耗费**体力**最小的一条路径。

一条路径耗费的**体力值**是路径上相邻格子之间**高度差绝对值**的**最大值**决定的。

请你返回从左上角走到右下角的最小**体力消耗值**。

## 示例

### 示例 1
```
输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的高度差绝对值最大是 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值是 3 。
```

### 示例 2
```
输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
输出：1
解释：路径 [1,2,3,4,5] 连续格子的高度差绝对值最大是 1 ，比路径 [1,3,5,3,5] 更优。
```

### 示例 3
```
输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
输出：0
解释：上图所示路径不需要消耗任何体力。
```

## 解法说明

本实现提供了三种解法：

### 方法1：Dijkstra 算法（推荐）

**核心思想：**
- 将问题转化为寻找最短路径问题
- 使用优先队列（最小堆）维护当前最小体力消耗
- 每次选择体力消耗最小的点进行扩展

**时间复杂度：** O(mn * log(mn))
**空间复杂度：** O(mn)

**优点：**
- 算法成熟，实现简单
- 效率较高
- 易于理解和调试

### 方法2：二分查找 + BFS

**核心思想：**
- 二分体力消耗值
- 对于每个中间值，使用 BFS 判断是否存在可行路径
- 根据判断结果调整搜索范围

**时间复杂度：** O(mn * log(max_height))
**空间复杂度：** O(mn)

**优点：**
- 当高度范围较大时，可能比 Dijkstra 更快
- 思路清晰，易于实现

### 方法3：并查集（Union-Find）

**核心思想：**
- 将所有边按体力消耗排序
- 按顺序加入边，使用并查集维护连通性
- 当起点和终点连通时，当前边的体力消耗就是答案

**时间复杂度：** O(mn * log(mn))
**空间复杂度：** O(mn)

**优点：**
- 离线算法，适合批量查询
- 思路独特，展示了并查集的应用

## 使用方法

```python
from leetcode_1631_minimum_effort_path import Solution

solution = Solution()

# 使用 Dijkstra 算法
heights = [[1,2,2],[3,8,2],[5,3,5]]
result1 = solution.minimumEffortPath(heights)
print(f"Dijkstra 算法结果: {result1}")  # 输出: 2

# 使用二分查找 + BFS
result2 = solution.minimumEffortPath_BinarySearch(heights)
print(f"二分查找结果: {result2}")  # 输出: 2

# 使用并查集
result3 = solution.minimumEffortPath_UnionFind(heights)
print(f"并查集结果: {result3}")  # 输出: 2
```

## 运行测试

```bash
python leetcode_1631_minimum_effort_path.py
```

测试程序会运行三个测试用例，并对比三种方法的结果。

## 性能对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|-----------|-----------|---------|
| Dijkstra | O(mn·log(mn)) | O(mn) | 通用，推荐 |
| 二分+BFS | O(mn·log(H)) | O(mn) | 高度范围大 |
| 并查集 | O(mn·log(mn)) | O(mn) | 批量查询 |

其中，H 表示高度的最大值。

## 关键要点

1. **理解题意**：体力消耗是路径上相邻格子高度差的**最大值**，而不是总和
2. **状态定义**：对于 Dijkstra，状态是到达某个点的最小体力消耗
3. **边界处理**：注意检查网格边界，避免数组越界
4. **优化技巧**：在 Dijkstra 中，如果当前体力消耗大于已知最小值，可以剪枝

## 相关题目

- LeetCode 778: 水位上升的泳池中游泳
- LeetCode 1102: 得分最高的路径
- LeetCode 1514: 概率最大的路径
